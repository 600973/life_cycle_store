<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Динамика продаж по неделям</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #f5f5f5; padding: 20px; }
        .container { max-width: 1400px; margin: 0 auto; background: white; border-radius: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); padding: 24px; }
        h1 { font-size: 24px; color: #333; margin-bottom: 20px; }
        
        .controls-panel { margin-bottom: 20px; padding: 16px; background: #f8f9fa; border-radius: 8px; border: 1px solid #e9ecef; display: flex; flex-direction: column; gap: 14px; }
        
        .controls-row { display: flex; gap: 16px; align-items: flex-end; flex-wrap: wrap; }
        
        .control-group { display: flex; flex-direction: column; gap: 4px; }
        .control-group label { font-weight: 600; font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 0.5px; }
        
        select { padding: 8px 12px; border: 1px solid #ced4da; border-radius: 6px; font-size: 13px; background: white; }
        
        .stores-row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
        .stores-row .section-label { font-weight: 600; font-size: 12px; color: #6c757d; text-transform: uppercase; letter-spacing: 0.5px; margin-right: 4px; }
        
        .checkbox-item { display: flex; align-items: center; gap: 5px; font-size: 13px; cursor: pointer; white-space: nowrap; }
        .checkbox-item input { cursor: pointer; }
        
        .section-box { border: 1px solid #dee2e6; border-radius: 6px; padding: 10px 14px; }
        .section-box .section-title { font-weight: 600; font-size: 11px; color: #6c757d; text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px; }
        .section-box .checkbox-row { display: flex; flex-wrap: wrap; gap: 16px; align-items: center; }
        
        .divider { height: 1px; background: #dee2e6; }
        
        button { padding: 5px 12px; border: 1px solid #ced4da; border-radius: 6px; background: white; cursor: pointer; font-size: 12px; }
        button:hover { background: #e9ecef; }
        .btn-sm { padding: 3px 10px; font-size: 11px; }
        
        #chart { width: 100%; height: 550px; }
        .table-container { overflow-x: auto; margin-top: 20px; }
        table { width: 100%; border-collapse: collapse; font-size: 13px; }
        th, td { padding: 8px 10px; text-align: right; border-bottom: 1px solid #e9ecef; white-space: nowrap; }
        th { background: #f8f9fa; font-weight: 600; cursor: pointer; user-select: none; position: sticky; top: 0; }
        th:hover { background: #e9ecef; }
        th:first-child, td:first-child { text-align: left; }
        tr:hover { background: #f0f4ff; }
        .color-dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; vertical-align: middle; }
        .totals-row { font-weight: 700; background: #f8f9fa; border-top: 2px solid #dee2e6; }
        .sort-arrow { font-size: 10px; margin-left: 4px; opacity: 0.5; }
        .metric-row { display: flex; align-items: flex-end; gap: 6px; }
        .help-btn { width: 22px; height: 22px; border-radius: 50%; border: 1px solid #adb5bd; background: white; color: #6c757d; font-size: 13px; font-weight: 700; cursor: pointer; display: flex; align-items: center; justify-content: center; margin-bottom: 2px; }
        .help-btn:hover { background: #e9ecef; color: #333; }
        .metric-tooltip { display: none; position: absolute; z-index: 100; background: white; border: 1px solid #dee2e6; border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.15); padding: 16px 20px; max-width: 420px; font-size: 13px; line-height: 1.6; color: #333; }
        .metric-tooltip.visible { display: block; }
        .metric-tooltip h4 { margin: 0 0 8px 0; font-size: 14px; color: #1f77b4; }
        .metric-tooltip p { margin: 0 0 6px 0; }
        .metric-tooltip code { background: #f1f3f5; padding: 1px 5px; border-radius: 3px; font-size: 12px; }
        .metric-tooltip .close-tip { position: absolute; top: 8px; right: 12px; cursor: pointer; font-size: 16px; color: #adb5bd; }
        .metric-tooltip .close-tip:hover { color: #333; }
        .view-switcher { display: flex; gap: 8px; margin-bottom: 16px; }
        .view-btn { padding: 8px 16px; border: 1px solid #ced4da; border-radius: 6px; background: white; cursor: pointer; }
        .view-btn.active { background: #1f77b4; color: white; border-color: #1f77b4; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Динамика продаж по неделям</h1>
        
        <div class="controls-panel">
            <!-- Строка 1: Метрика и диапазон недель -->
            <div class="controls-row">
                <div class="control-group">
                    <label>Метрика</label>
                    <div class="metric-row">
                        <select id="metric" onchange="updateChart()">
                            <option value="revenue" selected>Выручка</option>
                            <option value="growth_pct">Рост к пред. неделе (%)</option>
                            <option value="growth_index">Индекс роста (%)</option>
                            <option value="cumulative">Кумулятивная сумма</option>
                            <option value="moving_avg">Скользящее среднее (4 нед)</option>
                        </select>
                        <button class="help-btn" onclick="toggleMetricHelp(event)">?</button>
                    </div>
                    <div id="metricTooltip" class="metric-tooltip"></div>
                </div>
                <div class="control-group">
                    <label>Недели с</label>
                    <select id="weekFrom" onchange="onWeekFromChange()"></select>
                </div>
                <div class="control-group">
                    <label>по</label>
                    <select id="weekTo" onchange="updateChart()"></select>
                </div>
            </div>
            
            <!-- Строка 2: Магазины чекбоксами -->
            <div class="stores-row">
                <span class="section-label">Магазины:</span>
                <div id="storesCheckboxes"></div>
                <button class="btn-sm" onclick="selectAllStores()">Все</button>
                <button class="btn-sm" onclick="clearStores()">Сброс</button>
            </div>
            
            <div class="divider"></div>
            
            <!-- Строка 3: Показатели в рамке -->
            <div class="section-box">
                <div class="section-title">Показатели</div>
                <div class="checkbox-row">
                    <label class="checkbox-item"><input type="checkbox" id="showMean" checked onchange="updateChart()"> Средняя</label>
                    <label class="checkbox-item"><input type="checkbox" id="showMedian" onchange="updateChart()"> Медиана</label>
                    <label class="checkbox-item"><input type="checkbox" id="showCorridor" onchange="updateChart()"> Коридор min-max</label>
                    <label class="checkbox-item"><input type="checkbox" id="showTrend" onchange="updateChart()"> Линии тренда</label>
                    <label class="checkbox-item"><input type="checkbox" id="showLabels" onchange="toggleLabels()"> Значения</label>
                    <label class="checkbox-item"><input type="checkbox" id="alignRight" onchange="updateChart()"> Выравнивание справа</label>
                </div>
            </div>
        </div>
        
        <div class="view-switcher">
            <button class="view-btn active" onclick="showView('chart', this)">График</button>
            <button class="view-btn" onclick="showView('table', this)">Таблица</button>
        </div>
        <div id="chart"></div>
        <div id="tableContainer" class="table-container hidden"></div>
    </div>

<script>
const weeklySalesData = {
    stores: ["Магазин 1", "Магазин 2", "Магазин 3", "Магазин 4", "Магазин 5"],
    weeks: ["Неделя 1", "Неделя 2", "Неделя 3", "Неделя 4", "Неделя 5", "Неделя 6", "Неделя 7", "Неделя 8", "Неделя 9", "Неделя 10", "Неделя 11", "Неделя 12", "Неделя 13", "Неделя 14", "Неделя 15"],
    data: [[61185.0, 69389.0, 66336.0, 63119.0, 78146.0, 60630.0, 65842.0, 72851.0, 95955.0, 84195.0, 67401.0, 78178.0, 93721.0, 91653.0, 76634.0], [126553.0, 144333.0, 141448.0, 140672.0, 139609.0, 145892.0, 150916.0, 153482.0, 147060.0, 144001.0, 150789.0, 153038.0, 152191.0, 163644.0, 172813.0], [115508.0, 114687.0, 128379.0, 121705.0, 119327.0, 133955.0, 128747.0, 132433.0, 139654.0, 126330.0, 146457.0, 133631.0, null, null, null], [82801.0, 98191.0, 90834.0, 97433.0, 97112.0, 95815.0, 103626.0, 107940.0, 112745.0, 92246.0, null, null, null, null, null], [136488.0, 130733.0, 126569.0, 140740.0, 128291.0, 122064.0, 144469.0, null, null, null, null, null, null, null, null]]
};

const COLORS = ['#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2','#7f7f7f','#bcbd22','#17becf','#aec7e8','#ffbb78','#98df8a','#ff9896','#c5b0d5'];

function hashString(str) {
    let hash = 0;
    for (let i = 0; i < str.length; i++) {
        hash = ((hash << 5) - hash) + str.charCodeAt(i);
        hash |= 0;
    }
    return Math.abs(hash);
}

function getStoreColor(storeName) {
    return COLORS[hashString(storeName) % COLORS.length];
}

let lastAnnotations = [];

function toggleLabels() {
    const showLabels = document.getElementById('showLabels').checked;
    const chartDiv = document.getElementById('chart');
    if (chartDiv && chartDiv.data) {
        Plotly.relayout('chart', { annotations: showLabels ? lastAnnotations : [] });
    }
}

const METRIC_HELP = {
    revenue: {
        title: 'Выручка',
        text: 'Абсолютное значение выручки магазина за каждую неделю в рублях. Берётся напрямую из исходных данных без преобразований.'
    },
    growth_pct: {
        title: 'Рост к предыдущей неделе (%)',
        text: 'Процентное изменение выручки относительно предыдущей недели.<br><br><b>Формула:</b> <code>((Текущая - Предыдущая) / Предыдущая) &times; 100%</code><br><br>Положительные значения — рост, отрицательные — падение. Первая неделя не имеет значения, т.к. нет предыдущей.'
    },
    growth_index: {
        title: 'Индекс роста (%)',
        text: 'Показывает, как изменилась выручка относительно первой недели работы магазина. Первая неделя = 100%.<br><br><b>Формула:</b> <code>(Текущая неделя / Первая неделя) &times; 100%</code><br><br>Если индекс = 150%, значит выручка выросла на 50% от стартовой.'
    },
    cumulative: {
        title: 'Кумулятивная сумма',
        text: 'Нарастающий итог выручки с первой недели. Каждая точка — сумма всех предыдущих недель включительно.<br><br><b>Формула:</b> <code>Сумма(Неделя 1 + Неделя 2 + ... + Неделя N)</code><br><br>Полезна для оценки общего объёма продаж и сравнения магазинов по суммарной выручке за весь период.'
    },
    moving_avg: {
        title: 'Скользящее среднее (4 недели)',
        text: 'Среднее значение выручки за последние 4 недели. Сглаживает колебания и показывает общий тренд.<br><br><b>Формула:</b> <code>(Нед N-3 + Нед N-2 + Нед N-1 + Нед N) / 4</code><br><br>Первые 3 недели не имеют значения, т.к. недостаточно данных для окна в 4 недели.'
    }
};

function toggleMetricHelp(e) {
    e.stopPropagation();
    const tooltip = document.getElementById('metricTooltip');
    if (tooltip.classList.contains('visible')) {
        tooltip.classList.remove('visible');
        return;
    }
    const metric = document.getElementById('metric').value;
    const info = METRIC_HELP[metric];
    tooltip.innerHTML = `<span class="close-tip" onclick="document.getElementById('metricTooltip').classList.remove('visible')">&times;</span><h4>${info.title}</h4><p>${info.text}</p>`;
    tooltip.classList.add('visible');
}

document.addEventListener('click', (e) => {
    const tooltip = document.getElementById('metricTooltip');
    if (tooltip && !tooltip.contains(e.target) && !e.target.classList.contains('help-btn')) {
        tooltip.classList.remove('visible');
    }
});

function getSelectedStoreIndices() {
    return Array.from(document.querySelectorAll('#storesCheckboxes input[type="checkbox"]:checked')).map(cb => parseInt(cb.value));
}

function initSelectors() {
    const container = document.getElementById('storesCheckboxes');
    const weekFromSelect = document.getElementById('weekFrom');

    container.innerHTML = '';
    const row = document.createElement('div');
    row.style.display = 'flex';
    row.style.gap = '14px';
    row.style.flexWrap = 'wrap';
    weeklySalesData.stores.forEach((store, idx) => {
        const lbl = document.createElement('label');
        lbl.className = 'checkbox-item';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.value = idx;
        cb.checked = true;
        cb.onchange = updateChart;
        lbl.appendChild(cb);
        lbl.appendChild(document.createTextNode(' ' + store));
        row.appendChild(lbl);
    });
    container.appendChild(row);

    weekFromSelect.innerHTML = '';
    weeklySalesData.weeks.forEach((week, idx) => {
        weekFromSelect.innerHTML += `<option value="${idx}">${week}</option>`;
    });
    weekFromSelect.value = 0;
    updateWeekToOptions();
}

function onWeekFromChange() {
    updateWeekToOptions();
    updateChart();
}

function updateWeekToOptions() {
    const weekFromSelect = document.getElementById('weekFrom');
    const weekToSelect = document.getElementById('weekTo');
    const fromIdx = parseInt(weekFromSelect.value) || 0;
    const prevTo = parseInt(weekToSelect.value);

    weekToSelect.innerHTML = '';
    for (let i = fromIdx + 1; i < weeklySalesData.weeks.length; i++) {
        weekToSelect.innerHTML += `<option value="${i}">${weeklySalesData.weeks[i]}</option>`;
    }
    if (prevTo > fromIdx && prevTo < weeklySalesData.weeks.length) {
        weekToSelect.value = prevTo;
    } else {
        weekToSelect.value = weeklySalesData.weeks.length - 1;
    }
}

function selectAllStores() {
    document.querySelectorAll('#storesCheckboxes input[type="checkbox"]').forEach(cb => cb.checked = true);
    updateChart();
}

function clearStores() {
    document.querySelectorAll('#storesCheckboxes input[type="checkbox"]').forEach(cb => cb.checked = false);
    updateChart();
}

function showView(view, btn) {
    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('chart').classList.toggle('hidden', view !== 'chart');
    document.getElementById('tableContainer').classList.toggle('hidden', view !== 'table');
    if (view === 'table') generateTable();
    if (view === 'chart') Plotly.Plots.resize('chart');
}

function calculateMetrics(data) {
    const growth_pct = data.map(row => row.map((val, j) => {
        if (j === 0 || val === null || row[j-1] === null || row[j-1] === 0) return null;
        return ((val - row[j-1]) / row[j-1]) * 100;
    }));
    const growth_index = data.map(row => {
        const firstVal = row.find(v => v !== null && v > 0);
        if (!firstVal) return row.map(() => null);
        return row.map(val => val !== null ? (val / firstVal) * 100 : null);
    });
    const cumulative = data.map(row => {
        let sum = 0;
        return row.map(val => { if (val !== null) sum += val; return val !== null ? sum : null; });
    });
    const moving_avg = data.map(row => row.map((val, j) => {
        if (j < 3) return null;
        const w = row.slice(j - 3, j + 1);
        if (w.some(v => v === null)) return null;
        return w.reduce((a, b) => a + b, 0) / 4;
    }));
    return { revenue: data, growth_pct, growth_index, cumulative, moving_avg };
}

function getStatsFromMatrix(matrix, size) {
    const stats = { mean: [], median: [], min: [], max: [] };
    for (let j = 0; j < size; j++) {
        const values = [];
        for (let i = 0; i < matrix.length; i++) {
            const v = matrix[i][j];
            if (v !== null && v !== undefined && !isNaN(v)) values.push(v);
        }
        if (values.length > 0) {
            values.sort((a, b) => a - b);
            stats.mean.push(values.reduce((a, b) => a + b, 0) / values.length);
            stats.median.push(values.length % 2 === 1 ? values[Math.floor(values.length / 2)] : (values[values.length / 2 - 1] + values[values.length / 2]) / 2);
            stats.min.push(values[0]);
            stats.max.push(values[values.length - 1]);
        } else { stats.mean.push(null); stats.median.push(null); stats.min.push(null); stats.max.push(null); }
    }
    return stats;
}

function linearRegression(x, y) {
    const n = x.length;
    if (n < 2) return null;
    let sumX = 0, sumY = 0, sumXY = 0, sumXX = 0;
    for (let i = 0; i < n; i++) { sumX += x[i]; sumY += y[i]; sumXY += x[i] * y[i]; sumXX += x[i] * x[i]; }
    const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
    const intercept = (sumY - slope * sumX) / n;
    const yMean = sumY / n;
    let ssRes = 0, ssTot = 0;
    for (let i = 0; i < n; i++) { ssRes += (y[i] - (slope * x[i] + intercept)) ** 2; ssTot += (y[i] - yMean) ** 2; }
    return { slope, intercept, r2: ssTot > 0 ? 1 - ssRes / ssTot : 0 };
}

function updateChart() {
    const metric = document.getElementById('metric').value;
    let weekFrom = parseInt(document.getElementById('weekFrom').value) || 0;
    let weekTo = parseInt(document.getElementById('weekTo').value) || weeklySalesData.weeks.length - 1;
    const showMean = document.getElementById('showMean').checked;
    const showMedian = document.getElementById('showMedian').checked;
    const showCorridor = document.getElementById('showCorridor').checked;
    const showTrend = document.getElementById('showTrend').checked;
    const alignRight = document.getElementById('alignRight').checked;
    const selectedIndices = getSelectedStoreIndices();

    if (selectedIndices.length === 0) {
        document.getElementById('chart').innerHTML = '<p style="padding:40px;text-align:center;color:#666;">Выберите магазины</p>';
        return;
    }

    const metrics = calculateMetrics(weeklySalesData.data);
    const metricData = metrics[metric];
    const metricLabels = {'revenue':'Выручка','growth_pct':'Рост к пред. неделе (%)','growth_index':'Индекс роста (%)','cumulative':'Кумулятивная сумма','moving_avg':'Скользящее среднее (4 нед)'};
    const metricLabel = metricLabels[metric];

    // Автоматическое выравнивание по ширине
    let minWeek = weekTo;
    let maxWeek = weekFrom;
    selectedIndices.forEach(idx => {
        for (let j = weekFrom; j <= weekTo; j++) {
            const val = metricData[idx]?.[j];
            if (val !== null && val !== undefined && !isNaN(val)) {
                if (j < minWeek) minWeek = j;
                if (j > maxWeek) maxWeek = j;
            }
        }
    });
    if (minWeek <= maxWeek) {
        weekFrom = minWeek;
        weekTo = maxWeek;
    }

    const traces = [];
    const annotations = [];

    if (alignRight) {
        const storeShifts = {};
        let maxLast = 0;
        selectedIndices.forEach(idx => {
            let lastValid = -1;
            for (let j = weekFrom; j <= weekTo; j++) {
                const val = metricData[idx]?.[j];
                if (val !== null && val !== undefined && !isNaN(val)) lastValid = j - weekFrom;
            }
            if (lastValid >= 0) {
                storeShifts[idx] = lastValid;
                if (lastValid > maxLast) maxLast = lastValid;
            }
        });
        
        Object.keys(storeShifts).forEach(idx => {
            storeShifts[idx] = maxLast - storeShifts[idx];
        });
        
        const shiftedSize = maxLast + 1;
        let actualSize = shiftedSize;
        selectedIndices.forEach(idx => {
            if (storeShifts[idx] !== undefined) {
                const row = metricData[idx];
                for (let j = weekFrom; j <= weekTo; j++) {
                    const val = row?.[j];
                    if (val !== null && val !== undefined && !isNaN(val)) {
                        const newPos = (j - weekFrom) + storeShifts[idx];
                        if (newPos >= actualSize) actualSize = newPos + 1;
                    }
                }
            }
        });
        
        const shiftedMatrix = [];
        selectedIndices.forEach(idx => {
            const row = new Array(actualSize).fill(null);
            if (storeShifts[idx] !== undefined) {
                const shift = storeShifts[idx];
                for (let j = weekFrom; j <= weekTo; j++) {
                    const val = metricData[idx]?.[j];
                    if (val !== null && val !== undefined && !isNaN(val)) {
                        const newPos = (j - weekFrom) + shift;
                        if (newPos < actualSize) row[newPos] = val;
                    }
                }
            }
            shiftedMatrix.push(row);
        });
        
        const xAll = [];
        for (let i = 0; i < actualSize; i++) xAll.push(weekFrom + i + 1);
        
        if (showCorridor) {
            const stats = getStatsFromMatrix(shiftedMatrix, actualSize);
            traces.push({
                x: xAll.concat([...xAll].reverse()),
                y: stats.max.concat([...stats.min].reverse()),
                fill: 'toself', fillcolor: 'rgba(128,128,128,0.15)',
                line: { color: 'rgba(128,128,128,0)' },
                name: 'Коридор min-max', hoverinfo: 'skip'
            });
        }
        
        selectedIndices.forEach((storeIdx, i) => {
            if (storeShifts[storeIdx] === undefined) return;
            const storeName = weeklySalesData.stores[storeIdx];
            const shift = storeShifts[storeIdx];
            const color = getStoreColor(storeName);
            
            const xStore = [], yStore = [];
            for (let j = weekFrom; j <= weekTo; j++) {
                const val = metricData[storeIdx]?.[j];
                if (val !== null && val !== undefined && !isNaN(val)) {
                    xStore.push(weekFrom + (j - weekFrom) + shift + 1);
                    yStore.push(val);
                }
            }
            
            traces.push({
                x: xStore, y: yStore, mode: 'lines+markers', name: storeName,
                line: { color, width: 2 }, marker: { size: 6 },
                hovertemplate: `<b>${storeName}</b><br>Неделя: %{x}<br>${metricLabel}: %{y:,.0f}<extra></extra>`
            });
            
            if (showTrend && xStore.length >= 2) {
                const reg = linearRegression(xStore, yStore);
                if (reg) traces.push({
                    x: xStore, y: xStore.map(x => reg.slope * x + reg.intercept),
                    mode: 'lines', name: `${storeName} (тренд)`,
                    line: { color, width: 1, dash: 'dot' }, showlegend: false
                });
            }
            
            yStore.forEach((y, j) => {
                if (y !== null && !isNaN(y)) annotations.push({ x: xStore[j], y, text: Math.round(y).toLocaleString('ru-RU'), showarrow: false, font: { size: 8, color }, yshift: 10 });
            });
        });

        if (showMean) {
            const stats = getStatsFromMatrix(shiftedMatrix, actualSize);
            traces.push({ x: xAll, y: stats.mean, mode: 'lines', name: 'Средняя', line: { color: '#000', width: 3, dash: 'dash' } });
        }
        if (showMedian) {
            const stats = getStatsFromMatrix(shiftedMatrix, actualSize);
            traces.push({ x: xAll, y: stats.median, mode: 'lines', name: 'Медиана', line: { color: '#E91E63', width: 2, dash: 'dot' } });
        }
        
        var xValues = xAll;
    } else {
        const weekIndices = [];
        for (let i = weekFrom; i <= weekTo; i++) weekIndices.push(i);
        var xValues = weekIndices.map(i => i + 1);

        if (showCorridor) {
            const allRows = selectedIndices.map(idx => weekIndices.map(j => metricData[idx]?.[j] ?? null));
            const stats = getStatsFromMatrix(allRows, weekIndices.length);
            traces.push({
                x: xValues.concat([...xValues].reverse()),
                y: stats.max.concat([...stats.min].reverse()),
                fill: 'toself', fillcolor: 'rgba(128,128,128,0.15)',
                line: { color: 'rgba(128,128,128,0)' },
                name: 'Коридор min-max', hoverinfo: 'skip'
            });
        }

        selectedIndices.forEach((storeIdx, i) => {
            const storeName = weeklySalesData.stores[storeIdx];
            const yValues = weekIndices.map(j => metricData[storeIdx]?.[j]);
            const color = getStoreColor(storeName);

            traces.push({
                x: xValues, y: yValues, mode: 'lines+markers', name: storeName,
                line: { color, width: 2 }, marker: { size: 6 },
                hovertemplate: `<b>${storeName}</b><br>Неделя: %{x}<br>${metricLabel}: %{y:,.0f}<extra></extra>`
            });

            if (showTrend) {
                const pts = []; yValues.forEach((y, j) => { if (y !== null && !isNaN(y)) pts.push({ x: xValues[j], y }); });
                if (pts.length >= 2) {
                    const reg = linearRegression(pts.map(p => p.x), pts.map(p => p.y));
                    if (reg) traces.push({
                        x: pts.map(p => p.x), y: pts.map(p => reg.slope * p.x + reg.intercept),
                        mode: 'lines', name: `${storeName} (тренд)`, line: { color, width: 1, dash: 'dot' }, showlegend: false
                    });
                }
            }

            yValues.forEach((y, j) => {
                if (y !== null && !isNaN(y)) annotations.push({ x: xValues[j], y, text: Math.round(y).toLocaleString('ru-RU'), showarrow: false, font: { size: 8, color }, yshift: 10 });
            });
        });

        if (showMean) {
            const allRows = selectedIndices.map(idx => weekIndices.map(j => metricData[idx]?.[j] ?? null));
            const stats = getStatsFromMatrix(allRows, weekIndices.length);
            traces.push({ x: xValues, y: stats.mean, mode: 'lines', name: 'Средняя', line: { color: '#000', width: 3, dash: 'dash' } });
        }
        if (showMedian) {
            const allRows = selectedIndices.map(idx => weekIndices.map(j => metricData[idx]?.[j] ?? null));
            const stats = getStatsFromMatrix(allRows, weekIndices.length);
            traces.push({ x: xValues, y: stats.median, mode: 'lines', name: 'Медиана', line: { color: '#E91E63', width: 2, dash: 'dot' } });
        }
    }

    lastAnnotations = annotations;
    const showLabels = document.getElementById('showLabels').checked;
    const titleSuffix = alignRight ? ' (выравнивание справа)' : '';
    Plotly.newPlot('chart', traces, {
        title: { text: `Динамика продаж по неделям: ${metricLabel}${titleSuffix}`, font: { size: 18 } },
        xaxis: { title: 'Неделя работы', dtick: xValues.length <= 24 ? 1 : Math.ceil(xValues.length / 12), gridcolor: '#e9ecef' },
        yaxis: { title: metricLabel, gridcolor: '#e9ecef', tickformat: ',.0f' },
        plot_bgcolor: '#f8f9fa', paper_bgcolor: 'white',
        margin: { l: 80, r: 200, t: 60, b: 60 },
        legend: { x: 1.02, y: 1, xanchor: 'left', font: { size: 11 } },
        hovermode: 'x unified', annotations: showLabels ? annotations : []
    }, { responsive: true });
}

let tableSortCol = null;
let tableSortAsc = true;

function generateTable() {
    const selectedIndices = getSelectedStoreIndices();
    const metric = document.getElementById('metric').value;
    const metrics = calculateMetrics(weeklySalesData.data);
    const metricData = metrics[metric];
    const metricLabels = {revenue:'Выручка',growth_pct:'Рост к пред. неделе (%)',growth_index:'Индекс роста (%)',cumulative:'Кумулятивная сумма',moving_avg:'Скользящее среднее (4 нед)'};
    const metricLabel = metricLabels[metric];
    let weekFrom = parseInt(document.getElementById('weekFrom').value) || 0;
    let weekTo = parseInt(document.getElementById('weekTo').value) || weeklySalesData.weeks.length - 1;

    const rows = [];
    selectedIndices.forEach(idx => {
        const store = weeklySalesData.stores[idx];
        const color = getStoreColor(store);
        const allValues = [];
        let bestWeek = null, worstWeek = null, bestVal = -Infinity, worstVal = Infinity;
        for (let j = weekFrom; j <= weekTo; j++) {
            const v = metricData[idx]?.[j];
            if (v !== null && v !== undefined && !isNaN(v)) {
                allValues.push(v);
                if (v > bestVal) { bestVal = v; bestWeek = j + 1; }
                if (v < worstVal) { worstVal = v; worstWeek = j + 1; }
            }
        }
        if (allValues.length === 0) return;
        const first = allValues[0], last = allValues[allValues.length - 1];
        const growth = first !== 0 ? ((last / first - 1) * 100) : 0;
        const sum = allValues.reduce((a, b) => a + b, 0);
        const mean = sum / allValues.length;
        const sorted = [...allValues].sort((a, b) => a - b);
        const median = sorted.length % 2 === 1 ? sorted[Math.floor(sorted.length / 2)] : (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2;
        const min = sorted[0], max = sorted[sorted.length - 1];

        let slope = 0, r2 = 0;
        if (allValues.length >= 2) {
            const xArr = allValues.map((_, i) => i);
            const reg = linearRegression(xArr, allValues);
            if (reg) { slope = reg.slope; r2 = reg.r2; }
        }

        rows.push({ store, color, weeks: allValues.length, first, last, growth, mean, median, min, max, sum, slope, r2, bestWeek, worstWeek });
    });

    if (tableSortCol !== null) {
        rows.sort((a, b) => {
            const va = a[tableSortCol], vb = b[tableSortCol];
            if (typeof va === 'string') return tableSortAsc ? va.localeCompare(vb) : vb.localeCompare(va);
            return tableSortAsc ? va - vb : vb - va;
        });
    }

    const fmt = v => v !== null && v !== undefined ? Math.round(v).toLocaleString('ru-RU') : '—';
    const fmt1 = v => v !== null && v !== undefined ? v.toFixed(1) : '—';
    const fmt2 = v => v !== null && v !== undefined ? v.toFixed(2) : '—';
    const growthFmt = v => { const s = v > 0 ? '+' : ''; return `<span style="color:${v >= 0 ? '#2e7d32' : '#c62828'}">${s}${v.toFixed(1)}%</span>`; };
    const trendFmt = v => `<span style="color:${v >= 0 ? '#2e7d32' : '#c62828'}">${v > 0 ? '+' : ''}${fmt(v)}</span>`;

    const cols = [
        { key: 'store', label: 'Магазин' },
        { key: 'weeks', label: 'Недель' },
        { key: 'first', label: 'Первая' },
        { key: 'last', label: 'Последняя' },
        { key: 'growth', label: 'Рост (%)' },
        { key: 'mean', label: 'Средняя' },
        { key: 'median', label: 'Медиана' },
        { key: 'min', label: 'Мин' },
        { key: 'max', label: 'Макс' },
        { key: 'sum', label: 'Всего' },
        { key: 'slope', label: 'Тренд/нед' },
        { key: 'r2', label: 'R²' },
        { key: 'bestWeek', label: 'Лучш.' },
        { key: 'worstWeek', label: 'Худш.' }
    ];

    let html = `<table><thead><tr>`;
    cols.forEach(c => {
        const arrow = tableSortCol === c.key ? (tableSortAsc ? ' ▲' : ' ▼') : '';
        html += `<th onclick="sortTable('${c.key}')">${c.label}<span class="sort-arrow">${arrow}</span></th>`;
    });
    html += '</tr></thead><tbody>';

    rows.forEach(r => {
        html += `<tr>`;
        html += `<td><span class="color-dot" style="background:${r.color}"></span>${r.store}</td>`;
        html += `<td>${r.weeks}</td>`;
        html += `<td>${fmt(r.first)}</td>`;
        html += `<td>${fmt(r.last)}</td>`;
        html += `<td>${growthFmt(r.growth)}</td>`;
        html += `<td>${fmt(r.mean)}</td>`;
        html += `<td>${fmt(r.median)}</td>`;
        html += `<td>${fmt(r.min)}</td>`;
        html += `<td>${fmt(r.max)}</td>`;
        html += `<td>${fmt(r.sum)}</td>`;
        html += `<td>${trendFmt(r.slope)}</td>`;
        html += `<td>${fmt2(r.r2)}</td>`;
        html += `<td>${r.bestWeek}</td>`;
        html += `<td>${r.worstWeek}</td>`;
        html += `</tr>`;
    });

    if (rows.length > 1) {
        const allVals = rows.map(r => r.mean);
        const totalSum = rows.reduce((s, r) => s + r.sum, 0);
        const avgMean = allVals.reduce((a, b) => a + b, 0) / allVals.length;
        const avgMedian = rows.reduce((s, r) => s + r.median, 0) / rows.length;
        const totalMin = Math.min(...rows.map(r => r.min));
        const totalMax = Math.max(...rows.map(r => r.max));
        html += `<tr class="totals-row">`;
        html += `<td>Итого / Среднее</td>`;
        html += `<td>—</td>`;
        html += `<td>—</td>`;
        html += `<td>—</td>`;
        html += `<td>—</td>`;
        html += `<td>${fmt(avgMean)}</td>`;
        html += `<td>${fmt(avgMedian)}</td>`;
        html += `<td>${fmt(totalMin)}</td>`;
        html += `<td>${fmt(totalMax)}</td>`;
        html += `<td>${fmt(totalSum)}</td>`;
        html += `<td>—</td>`;
        html += `<td>—</td>`;
        html += `<td>—</td>`;
        html += `<td>—</td>`;
        html += `</tr>`;
    }

    document.getElementById('tableContainer').innerHTML = html + '</tbody></table>';
}

function sortTable(col) {
    if (tableSortCol === col) { tableSortAsc = !tableSortAsc; }
    else { tableSortCol = col; tableSortAsc = true; }
    generateTable();
}

document.addEventListener('DOMContentLoaded', () => { initSelectors(); updateChart(); });
</script>
</body>
</html>